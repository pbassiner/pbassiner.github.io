This is the first blog post of the series about web browser automation using [Scalatest](http://www.scalatest.org/) and [Selenium WebDriver](http://www.seleniumhq.org/projects/webdriver/) from the perspective of testing.

# Scalatest
[Scalatest](http://www.scalatest.org/) is the *de facto* standard testing library for Scala. Some other well known alternatives are [specs2](http://etorreborre.github.io/specs2/) and [ÂµTest](https://github.com/lihaoyi/utest).

Scalatest is simple but yet powerful and flexible. It offers several testing styles including xUnit-like, BDD and property-based testing.

Take a look at this minimal example, taken from their user guide:
<script src="https://gist.github.com/pbassiner/fbae9ca56ce7c61d446a88327eccf205.js?file=ScalatestExample.scala"></script>

One nice feature, that makes tests more concise and easier to write and maintain, are the matchers: a DSL for expressing assertions in tests using the word `should`. For example:
* `result should equal (3)`
* `result should have length 3`
* `string should fullyMatch regex """(-)?(\d+)(\.\d*)?"""`
* `List(1, 2, 3, 4, 5) should contain oneOf (5, 7, 9)`

# Selenium
Selenium Webdriver provides an API to automate browsers in several languages, including Java.

This example is extracted from their documentation:
<script src="https://gist.github.com/pbassiner/fbae9ca56ce7c61d446a88327eccf205.js?file=SeleniumWebDriverExample.java"></script>

# Scalatest + Selenium
The Selenium DSL for Scalatest follows the same principles and makes using Selenium very straightforward.

This is the re-write of the previous example using scalatest:
<script src="https://gist.github.com/pbassiner/fbae9ca56ce7c61d446a88327eccf205.js?file=ScalatestSeleniumExample.scala"></script>

As you can see, the DSL simplifies the interaction with the Selenium WebDriver:
* The `textField` method will try to find an element with the specified `string` as an identifier and, if it fails to do so, it will try to find it by name instead.
* Then you can set the value of the text field just by modifying its `value`
* The `submit` method will look for the form and submit it
* The page title is directly available through `pageTitle`

On the other hand, the usage of Scalatest allows to wrap the assertions within an `eventually` block, which will be executed until it succeeds or the timeout, which can be configured, has been exceeded.

The DSL provides many helper methods to ease the interaction with UI elements, such as:
* input type selectors like `textField`, `pwdField`, `checkbox` or `emailField`, for instance
* XPath lookups
* Manage cookies
* Manage multiple windows and tabs
* Run JavaScript code

Most of these features are already provided by Selenium WebDriver but the DSL for Scalatest makes it easier and clearer.

# Conclusion
Using Selenium along with Scalatest is quite convenient because it's more readable than the Java equivalent. Furthermore, it allows to have more consistency as you can use Scalatest for unit, integration and UI tests. A single test could perform UI actions, interact with APIs and query databases if necessary.

In upcoming posts I'll describe more complex, real-world scenarios in which the combination of both libraries simplifies UI testing.

# References
* [Scalatest testing styles](http://www.scalatest.org/user_guide/selecting_a_style)
* [Scalatest matchers](http://www.scalatest.org/user_guide/using_matchers)
* [Using Selenium with Scalatest](http://www.scalatest.org/user_guide/using_selenium)
